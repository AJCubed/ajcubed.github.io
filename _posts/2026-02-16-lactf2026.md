---
layout: post
title:  "LACTF 2026!"
date:   2026-02-16
categories: ctf
permalink: /lactf-2026
summary: "Writeups for some web challs at LACTF 2026"
---
Last weekend I participated in LACTF 2026. This year I challenged myself to work on web challenges, which I don't typically try. I hope outlining my experience will be helpful for others who are looking to learn how to approach unfamiliar CTF problems!

In the end, I finished four challenges:
1. The Trial
2. Mutation Mutation
3. Invoice Generator
4. Blogler (with some help)


# The Trial 
Our starting page looks like this:

![The Trial]({{'/assets/images/the_trial.jpg' | relative_url}}){:width="550"}

We can use context to conclude that we need to submit the phrase "I want the flag" to receive the flag. We can also click the "I'm Feeling Lucky" button to get rick-rolled.

The slider is rotating, and thus very difficult to move manually. 

The key bypass to rely on here is that any form you see on a website is only an interface to send some kind of request to that site‚Äîyou can bypass this user-hostile UI entirely if you get the endpoint for the form.

So we open up the inspect panel and view the Javascript. (Inspect -> Sources)

We look for the Javascript controlling the button, and see this snippet here:

```javascript
submit.addEventListener("click", async () => {
  const req = await fetch("/getflag", { //1
    method: "POST", //2
    body: `word=${encodeURIComponent(disp.textContent)}`, //3
    headers: {
      "Content-Type": "application/x-www-form-urlencoded" // 4
    }
  });
  msg.textContent = await req.text();
});
```

When we're crafting our own request, we'll need to make use of four pieces of information (I've annotated the code above):
1. the endpoint (the location we want to send our request to) is "/getflag"
2. it's submitting a POST request, so we'll do the same
3. the variable we're submitting to is called "word"
4. this is their header‚Äîwe'll send the same thing

I'll write my request using curl, but you can use other languages too. 

```bash
curl -X POST https://the-trial.chall.lac.tf/getflag \
¬† -H "Content-Type: application/x-www-form-urlencoded" \
¬† --data "word=flag"
```
If you're not familiar with curl, look closer and try to compare how the four pieces of information I've outlined are encoded in the original Javascript versus in my request.

Typing this in your terminal and hitting enter gives you your solve!
```bash
Ah, you want the flag? Well here you go! 
lactf{gregor_samsa_awoke_from_wait_thats_the_wrong_book}
```
<br>

# Mutation Mutation
This challenge is much more straightforward. Opening the site reveals a home screen telling us to inspect the page for the flag. Opening the inspect panel reveals this:

![Mutation Mutation]({{'/assets/images/mutation_mutation.jpg' | relative_url}}){:width="550"}

We can see that there's a flood of HTML comments that are drowning out the real flag, which is presumably also an HTML comment in this sea. The fake flags are changing far too quickly to find through screenshots like this.

My first instinct was to record the screen and pick out the flag. This did reveal the line containing the flag, but it was incredibly long and contained emojis, math symbols, and Tamil‚Äîso it was clear the challenge wanted us to obtain the text from the browser.

That's fine. We know it's Javascript injecting the comments, so in the same Inspect -> Sources tab, we can hit the pause button on the lower left. After that, it's ten seconds of scrolling through the flags and you can copy the flag directly from the HTML source:
```
lactf{—Å0n—ït–∞nt_mut–∞t—ñ0n_1sfun!üß¨üëãüèΩ–Ül–Ü1| ÿ∂Ìîã‘°‡≥á‚àë·¶û‡≠ûÎïæ·•â‡ºÇ‚Üó€ë‡ØÄ·§º‡¥Ø‚åÉ¬±‚ù£”¢‚óº‡Øå‡Øå‡Øå‡Øå‡Øå}
```

<br>

# Invoice Generator
This challenge involves a bit more web knowledge. We're given a file containing three files:
- `docker-compose.yml` (site deployment info)
- `/flag` (source code for the page containing the flag)
- `/invoice-generator` (source code for the invoice-generating page)

The best way to understand the setup of challenges like this are to view the site and its Dockerfile.

![Invoice Generator]({{'/assets/images/invoice_generator.jpg' | relative_url}}){:width="550"}

We can see the interface available to us. Are there any other endpoints? 
```bash
# Dockerfile
services:
  invoice-generator:
    build: ./invoice-generator
    ports:
      - "3000:3000"
    networks:
      - app-network
    depends_on:
      - flag

  flag:
    build: ./flag
    networks:
      - app-network

networks:
  app-network:
    driver: bridge
```

This tells us some useful info about the structure of the deployment:
1. only `/invoice-generator` is public, since it has an exposed port
2. `/flag` only exists as part of `app-network`, which is private
3. `app-network` is a *bridge*, meaning that `/invoice-generator` can communicate with `/flag`

This means we need to submit something to invoice-generator that'll get it to request the flag from `/flag` for us, since we can't access it directly. 

We have plenty of options for input‚Äîthere are four boxes here. Lets view the source code of this page to see how they're sanitizing our input. 

The bulk of `server.js` is the method `function generateInvoiceHTML(name, item, cost, datePurchased)`, which returns the HTML-formatted invoice. 

Looking inside, we can see where our input is fed into the invoice:

```html
    <div class="customer-info">
      <strong>Bill To:</strong>
      ${name}
    </div>

    <table>
      <thead>
        <tr>
          <th>Description</th>
          <th class="text-right">Unit Price</th>
          <th class="text-right">Quantity</th>
          <th class="text-right">Amount</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>${item}</td>
          <td class="text-right">$${cost.toFixed(2)}</td>
          <td class="text-right">1</td>
          <td class="text-right">$${cost.toFixed(2)}</td>
        </tr>
      </tbody>
    </table>

    <!-- more cost formatting so i cut it out -->

    <div class="customer-info">
      <strong>Date Purchased:</strong>
      ${datePurchased}
    </div>
  </body>
  </html>
```

Turns out, they aren't sanitizing our input at all! You can see that the four parameters are just injected directly into the HTML as ${name}, ${item}, ${cost}, and ${datePurchased}.

This means we can insert an HTML element in there, and it'll get rendered like HTML instead of a user-inputted string. (HTML injection!)

We want to inject an HTML element that has the ability to request resources from another page‚Äîanother page like `/flag`, perhaps? A quick google search tells us that we can use an iFrame for our purposes. 

Lets view the `/flag` source code to see how to format our injection.

```js
// flag.js
const http = require("http");

const FLAG = process.env.FLAG || "lactf{fake_flag}";
const PORT = 8081; // 1

const server = http.createServer((req, res) => {
  if (req.method === "GET" && req.url === "/flag") {
    res.writeHead(200, { "Content-Type": "text/html" });
    res.end(`<div><strong>FLAG:</strong> ${FLAG}</div>`); // 2
    return;
  }
  res.writeHead(404, { "Content-Type": "text/plain" });
  res.end("Not found");
});

server.listen(PORT, () => {
  console.log(`Flag service running on port ${PORT}`);
});
```

This tells us two things we want to know:
1. the port that this endpoint is running on is 8081
2. the flag is just rendered directly as html on the page

Thus, inputting `<iframe src='http://flag:8081/flag' width=800 height=350></iframe>` in our name field and hitting submit on our invoice gives us our flag!

![Invoice Generator Solve]({{'/assets/images/invoice_generator_solve.jpg' | relative_url}}){:width="550"}

# Blogler
This was the hardest of the four‚Äîcreds to one of our alums Aadi for explaining it to me!

Once again, we're given the source code for a site. Let's open up the Dockerfile to take a look at where the flag on this one is hiding.
```bash
FROM python:3.12-slim-bookworm

WORKDIR /app
RUN pip install --no-cache-dir flask gunicorn mistune PyYAML
COPY static/ /app/static/
COPY templates/ /app/templates/
COPY app.py /app
COPY flag /flag

CMD [ "gunicorn", "-w", "1", "app:app", "-b", "0.0.0.0:3000" ]
```

This tells us that the flag is copied into the root directory of the Docker image. This is a pretty big clue that we'll have to do some path traversal.

Once you log in, the site looks like this. Some clicking around will reveal that you can upload a blog post (which has a title and content), view your blog posts, or update the config file for your blog‚Äîthis includes your username, blog names, etc. 

![Blogler]({{'/assets/images/blogler.jpg' | relative_url}}){:width="550"}

Looking at the code leads us to the method we need to exploit:
```py
def validate_conf(old_cfg: dict, uploaded_conf: str) -> dict | str:
    try:
        conf = yaml.safe_load(uploaded_conf)

        # validate all blog entries
        for i, blog in enumerate(conf["blogs"]):
            if not isinstance(blog.get("title"), str):
                return f"please provide a 'title' to the {i+1}th blog"

            # no lfi
            file_name = blog["name"]
            assert isinstance(file_name, str)
            file_path = (blog_path / file_name).resolve()
            if "../" in file_name or file_name.startswith("/") or not file_path.is_relative_to(blog_path):
                return f"file path {file_name!r} is a hacking attempt. this incident will be reported"

        # recover from missing display name/passwords with sane default of old one
        if not isinstance(conf.get("user"), dict):
            conf["user"] = dict()

        conf["user"]["name"] = display_name(conf["user"].get("name", old_cfg["user"]["name"]))
        conf["user"]["password"] = conf["user"].get("password", old_cfg["user"]["password"])
        if not isinstance(conf["user"]["password"], str):
            return "provide a valid password bro"
        return conf
    except Exception as e:
        return f"exception - {e}"
```

The comments about LFI (local file inclusion) and attempts at input sanitization immediately make me suspicious. Looking at the code that serves the blog, we can confirm it's LFI:
```py
def serve_blog(username):
    if username not in users:
        return "username does not exist", 404
    blogs = [
        {"title": blog["title"], "content": mistune.html((blog_path / blog["name"]).read_text())}
        for blog in users[username]["blogs"]
    ]
    return render_template("blog.html", blogs=blogs, name=users[username]["user"]["name"])
```

This constructs a path with `blog_path / blog["name"]`, and then serves the contents of that file. If `blog["name"]` happens to be '../../flag', we'll get served the flag.

Then, `validate_conf` is the gatekeeper we need to break. But how? The sanitization check is pretty foolproof.

```python
if "../" in file_name or file_name.startswith("/") or not file_path.is_relative_to(blog_path):
```

You can try getting around these checks. As a spoiler, every LFI exploit I tried on my blog name failed (escapes, null bytes, any other odd formatting trick you could think of, all a bust.) Inputting directly into blogs.name won't work. 

So I asked Chat, and learned about YAML aliases. This is the default YAML config:
```yaml
blogs:
- name: sanitization target
  title: title
user:
  name: Aj
  password: test
```

But instead, we can define the name and title of the blog in our *user* segment instead of the *blogs* segment:
```yaml
user: &ref
  name: "../../flags"
  title: title
  password: pw
blogs:
- *ref
```
This will make the `blogs` object point to the same object as `user`. Then, blogs.name will be "../../flag", which......still doesn't help us. 

Since they're the same object, the sanitization check still acts on that same string, and we'll get caught in our hacking attempt. But lets go back to the `validate_conf` method. Is there anywhere else that any data gets mutated?

Yes! This happens after our sanitization check:
```py
conf["user"]["name"] = display_name(conf["user"].get("name", old_cfg["user"]["name"]))
conf["user"]["password"] = conf["user"].get("password", old_cfg["user"]["password"])
```

What's this display_name method? 
```py
def display_name(username: str) -> str:
    return "".join(p.capitalize() for p in username.split("_"))
```

It directly modifies the element in our YAML, user.name, to remove all the underscores. But doing that to user.name will also do that for blog.name....

So, it's looking like if we add underscores to break up the "../" strings in our LFI bypass, it'll pass the sanitization check, and then get all the underscores removed afterward! (I'm told this is a Time-of-Check-Time-of-Use exploit.)

So, what if we pass in this new string into our config?
```yaml
user: &ref
  name: ".._/.._/flags"
  title: title
  password: pw
blogs:
- *ref
```
This will pass the checks, and then get retroactively mutated into the correct filepath!

Hitting the blogs button will take you to your list of blog posts, and you'll get the flag `lactf{7m_g0nn4_bl0g_y0u}`!

---
<br>
That's all for my LACTF 2026 solves! Hope you had fun or learned something :)